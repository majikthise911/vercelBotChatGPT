function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
import axios from 'axios';
import getLogger from './log.js';
import { loadConfiguration } from './shared/Configuration.js';
import { SteamshipError } from './steamship_error.js';
import { Task } from './task.js';
import { TaskState } from './types/base.js';
import { isNode } from './utils.js';
function doFetch(_x, _x2) {
  return _doFetch.apply(this, arguments);
} // async function doFetch(url: any, opts: any): Promise<AxiosResponse> {
//   return new Promise<AxiosResponse>((resolve, reject) => {
//     axios({
//       url,
//       headers: opts.headers,
//       data: opts.body,
//       method: opts.method,
//     }).then(resolve)
//       .catch(
//         (err) => {
//           console.log(err);
//           reject(err);
//         }
//       )
//   })
// }
function _doFetch() {
  _doFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url, opts) {
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          return _context8.abrupt("return", axios({
            url: url,
            headers: opts.headers,
            data: opts.body,
            method: opts.method,
            responseType: opts.responseType
          }));
        case 1:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _doFetch.apply(this, arguments);
}
var log = getLogger('Steamship:ApiBase');
var MAX_BODY_LENGTH = 100000 * 1000;
var _SUBDOMAIN_REWRITING_ENDPOINTS = ['//steamship.run', '//apps.staging.steamship.com'];
var _USE_SUBDOMAIN_REWRITING = function _USE_SUBDOMAIN_REWRITING(base) {
  for (var _i = 0, _SUBDOMAIN_REWRITING_ = _SUBDOMAIN_REWRITING_ENDPOINTS; _i < _SUBDOMAIN_REWRITING_.length; _i++) {
    var s = _SUBDOMAIN_REWRITING_[_i];
    if (base.includes(s)) {
      return true;
    }
  }
  return false;
};

/* Should be a FormData object */
function addMultiparts(formData, path, value) {
  /* Decode any object into a series of HTTP Multi-part segments that Vapor will consume.
    https://github.com/vapor/multipart-kit
     When sending a JSON object in a MultiPart request, Vapor wishes to see multi part segments as follows:
    single_key
    array_key[idx]
    obj_key[prop]
     So a File with a list of one tag with kind=Foo would be transmitted as setting the part:
    [tags][0][kind]
  */
  var type = typeof value;
  if (type == 'string' || type == 'boolean' || type == 'number') {
    formData.append(path, value);
  } else if (Array.isArray(value)) {
    value.forEach(function (subValue, index) {
      addMultiparts(formData, path + "[" + index + "]", subValue);
    });
  } else {
    for (var _key in value) {
      addMultiparts(formData, path + "[" + _key + "]", value[_key]);
    }
  }
}
export var ApiBase = /*#__PURE__*/function () {
  function ApiBase(params) {
    var _this = this;
    _classCallCheck(this, ApiBase);
    _defineProperty(this, "config", void 0);
    this.config = loadConfiguration(params).then(function (config) {
      if (config.apiKey) {
        return _this._switchConfigWorkspace({
          workspaceHandle: params == null ? void 0 : params.workspace,
          failIfWorkspaceExists: (params == null ? void 0 : params.failIfWorkspaceExists) === true,
          config: config
        });
      } else {
        return config;
      }
    });
  }
  _createClass(ApiBase, [{
    key: "switchWorkspace",
    value: function () {
      var _switchWorkspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
        var config;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = this;
              _context.t1 = _extends;
              _context.t2 = {};
              _context.t3 = params;
              _context.next = 6;
              return this.config;
            case 6:
              _context.t4 = _context.sent;
              _context.t5 = {
                config: _context.t4
              };
              _context.t6 = (0, _context.t1)(_context.t2, _context.t3, _context.t5);
              _context.next = 11;
              return _context.t0._switchConfigWorkspace.call(_context.t0, _context.t6);
            case 11:
              config = _context.sent;
              this.config = Promise.resolve(config);
              log.info("Switched to workspace " + config.workspaceHandle + "/" + config.workspaceId);
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function switchWorkspace(_x3) {
        return _switchWorkspace.apply(this, arguments);
      }
      return switchWorkspace;
    }()
    /*
      Switches this client to the requested workspace, possibly creating it. If all arguments are None, the client
      actively switches into the default workspace.
       - API calls are performed manually to not result in circular imports.
      - Note that the default workspace is technically not necessary for API usage; it will be assumed by the Engine
        in the absense of a Workspace ID or Handle being manually specified in request headers.
     */
  }, {
    key: "_switchConfigWorkspace",
    value: function () {
      var _switchConfigWorkspace2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
        var workspace, p, oldConfig, activeConfig, returnId, returnHandle;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              workspace = undefined;
              p = _extends({}, params);
              if (!p.workspaceHandle) {
                p.workspaceHandle = 'default';
              }
              if (p.failIfWorkspaceExists) {
                log.info("Creating workspace with handle: " + p.workspaceHandle + ".");
              } else {
                log.info("Creating/Fetching workspace with handle: " + p.workspaceHandle + ".");
              }

              // Zero out the workspace_handle on the config block in case we're being invoked from
              // `init` (otherwise we'll attempt to create the sapce IN that nonexistant workspace)
              oldConfig = params.config;
              activeConfig = _extends({}, oldConfig, {
                workspaceHandle: undefined,
                workspaceId: undefined
              });
              _context2.next = 8;
              return this.post('workspace/create', {
                handle: p.workspaceHandle,
                fetchIfExists: !(p.failIfWorkspaceExists === true)
              }, {
                responsePath: 'workspace'
              }, activeConfig);
            case 8:
              workspace = _context2.sent;
              if (!(!workspace || !workspace.output)) {
                _context2.next = 11;
                break;
              }
              throw new SteamshipError({
                statusMessage: 'Was unable to switch to new workspace: server returned empty Workspace.'
              });
            case 11:
              returnId = workspace.output.id;
              returnHandle = workspace.output.handle;
              if (!(!returnHandle || !returnId)) {
                _context2.next = 16;
                break;
              }
              log.error(workspace);
              throw new SteamshipError({
                statusMessage: JSON.stringify(workspace) + " Unable to switch to workspace " + p.workspaceHandle + " with failIfWorkspaceExists " + p.failIfWorkspaceExists + ": server returned empty ID and Handle."
              });
            case 16:
              return _context2.abrupt("return", _extends({}, oldConfig, {
                workspaceHandle: returnHandle,
                workspaceId: returnId
              }));
            case 17:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _switchConfigWorkspace(_x4) {
        return _switchConfigWorkspace2.apply(this, arguments);
      }
      return _switchConfigWorkspace;
    }()
  }, {
    key: "_headers",
    value: function _headers(config, postConfig) {
      var ret = {
        'Content-Type': 'application/json',
        Authorization: "Bearer " + config.apiKey
      };
      if (postConfig != null && postConfig.workspaceId) {
        ret['X-Workspace-Id'] = postConfig == null ? void 0 : postConfig.workspaceId;
      } else if (config.workspaceId) {
        ret['X-Workspace-Id'] = config.workspaceId;
      } else if (config.workspaceHandle) {
        ret['X-Workspace-Handle'] = config.workspaceHandle;
      }
      if ((postConfig == null ? void 0 : postConfig.isPackageCall) === true) {
        if (postConfig != null && postConfig.packageOwner) {
          ret['X-Package-Owner-Handle'] = postConfig.packageOwner;
        }
        if (postConfig != null && postConfig.packageId) {
          ret['X-Package-Id'] = postConfig.packageId;
        }
        if (postConfig != null && postConfig.packageInstanceId) {
          ret['X-Package-Instance-Id'] = postConfig.packageInstanceId;
        }
      }
      if ((postConfig == null ? void 0 : postConfig.asBackgroundTask) === true) {
        // Will result in the engine persisting the inbound HTTP request as a Task for deferred
        // execution. The client will receive task information back instead of the synchronous API response.
        // That task can be polled for eventual completion.
        ret['X-Task-Background'] = 'true';
      }
      return ret;
    }
  }, {
    key: "_url",
    value: function _url(baseConfig, postConfig, operation) {
      var base = '';
      if (!((postConfig == null ? void 0 : postConfig.isPackageCall) === true)) {
        // It's an API call
        base = (postConfig == null ? void 0 : postConfig.apiBase) || baseConfig.apiBase;
      } else {
        // It's a package call
        if (!(postConfig != null && postConfig.packageOwner)) {
          throw new SteamshipError({
            statusCode: 'UserMissing',
            statusMessage: "Can not invoke an package endpoint without the package owner's user handle.",
            statusSuggestion: 'Provide the packageOwner option, or initialize your package with a lookup.'
          });
        }
        base = (postConfig == null ? void 0 : postConfig.appBase) || baseConfig.appBase;
        if (!base) {
          throw new SteamshipError({
            statusCode: 'EndpointMissing',
            statusMessage: 'Can not invoke an package endpoint without the App Base variable set.',
            statusSuggestion: 'This should automatically have a good default setting. Reach out to our Steamship support.'
          });
        }
        if (_USE_SUBDOMAIN_REWRITING(base)) {
          // Rewrite the base to be https://user.base
          var parts = base.split('//');
          if (parts.length < 2) {
            throw new SteamshipError({
              statusCode: 'EndpointInvalid',
              statusMessage: 'You package base did not appear to begin with a valid HTTP or HTTPS protocol.',
              statusSuggestion: "Make sure you've provided an app base such as https://steamship.run, with the protocol."
            });
          }
          // Now we pre-pend the app-base to the first part!
          parts[1] = (postConfig == null ? void 0 : postConfig.packageOwner) + "." + parts[1];
          base = parts.join('//');
        }
      }

      // Guard against a double // after the domain

      if (base && base[base.length - 1] == '/') {
        base = base.slice(0, base.length - 1);
      }
      if (operation && operation[0] == '/') {
        operation = operation.slice(1);
      }
      return base + "/" + operation;
    }
  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(operation, payload, config, overrideConfig) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.call('POST', operation, payload, config, overrideConfig));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function post(_x5, _x6, _x7, _x8) {
        return _post.apply(this, arguments);
      }
      return post;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(operation, payload, config) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.call('GET', operation, payload, config));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function get(_x9, _x10, _x11) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
  }, {
    key: "_makeError",
    value: function () {
      var _makeError2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref) {
        var error, response, task, j;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              error = _ref.error, response = _ref.response, task = _ref.task;
              if (!error) {
                _context5.next = 5;
                break;
              }
              return _context5.abrupt("return", error);
            case 5:
              if (!response) {
                _context5.next = 20;
                break;
              }
              _context5.prev = 6;
              _context5.next = 9;
              return response.data;
            case 9:
              j = _context5.sent;
              if (!j.status) {
                _context5.next = 12;
                break;
              }
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: j.status.statusMessage,
                statusCode: j.status.statusCode,
                statusSuggestion: j.status.statusSuggestion
              }));
            case 12:
              _context5.next = 17;
              break;
            case 14:
              _context5.prev = 14;
              _context5.t0 = _context5["catch"](6);
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: 'Bad response from server'
              }));
            case 17:
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: 'Bad response from server'
              }));
            case 20:
              if (!task) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: task.statusMessage,
                statusCode: task.statusCode,
                statusSuggestion: task.statusSuggestion
              }));
            case 22:
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: 'Bad response'
              }));
            case 23:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[6, 14]]);
      }));
      function _makeError(_x12) {
        return _makeError2.apply(this, arguments);
      }
      return _makeError;
    }()
  }, {
    key: "_makeResponse",
    value: function () {
      var _makeResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var _json, _json2;
        var response, rawResponse, objectConstructor, responsePath, err, json, taskParams, task, _task;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              response = _ref2.response, rawResponse = _ref2.rawResponse, objectConstructor = _ref2.objectConstructor, responsePath = _ref2.responsePath;
              if (response) {
                _context6.next = 3;
                break;
              }
              throw new SteamshipError({
                statusMessage: 'No response.'
              });
            case 3:
              if (!(response.status != 200)) {
                _context6.next = 8;
                break;
              }
              _context6.next = 6;
              return this._makeError({
                response: response
              });
            case 6:
              err = _context6.sent;
              throw err;
            case 8:
              if (!rawResponse) {
                _context6.next = 10;
                break;
              }
              return _context6.abrupt("return", response);
            case 10:
              _context6.prev = 10;
              json = response.data; // Axios
              // json = JSON.parse((response as any).body); // Got
              // json = await response.json(); // for the fetch style // Fetch
              _context6.next = 19;
              break;
            case 14:
              _context6.prev = 14;
              _context6.t0 = _context6["catch"](10);
              _context6.next = 18;
              return this._makeError({
                error: _context6.t0
              });
            case 18:
              throw _context6.sent;
            case 19:
              if (!(typeof json == 'undefined' || json == null)) {
                _context6.next = 21;
                break;
              }
              throw new SteamshipError({
                statusMessage: 'Empty response.'
              });
            case 21:
              taskParams = (_json = json) == null ? void 0 : _json.status;
              if (!(typeof (taskParams == null ? void 0 : taskParams.state) != 'undefined')) {
                _context6.next = 30;
                break;
              }
              task = new Task(this, _extends({}, taskParams, {
                responsePath: responsePath,
                rawResponse: rawResponse,
                objectConstructor: objectConstructor
              }));
              if (!(((_task = task) == null ? void 0 : _task.state) == TaskState.failed)) {
                _context6.next = 28;
                break;
              }
              _context6.next = 27;
              return this._makeError({
                task: task
              });
            case 27:
              throw _context6.sent;
            case 28:
              _context6.next = 31;
              break;
            case 30:
              task = new Task(this, {
                responsePath: responsePath,
                rawResponse: rawResponse,
                objectConstructor: objectConstructor
              });
            case 31:
              task.setData((_json2 = json) == null ? void 0 : _json2.data);
              return _context6.abrupt("return", task);
            case 33:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[10, 14]]);
      }));
      function _makeResponse(_x13) {
        return _makeResponse2.apply(this, arguments);
      }
      return _makeResponse;
    }()
  }, {
    key: "call",
    value: function () {
      var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(verb, operation, payload, config, overrideConfig) {
        var baseConfig, url, headers, reqConfig, finalPayload, contentType, FormDataNode, formData, pp, _i2, _Object$keys, _key2, value, _formData, _pp, _i3, _Object$keys2, _key3, _value, resp;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.t0 = overrideConfig;
              if (_context7.t0) {
                _context7.next = 5;
                break;
              }
              _context7.next = 4;
              return this.config;
            case 4:
              _context7.t0 = _context7.sent;
            case 5:
              baseConfig = _context7.t0;
              if (baseConfig.apiKey) {
                _context7.next = 8;
                break;
              }
              throw new SteamshipError({
                statusCode: 'Authentication',
                statusMessage: 'API Key not found.',
                statusSuggestion: 'Please see docs.steamship.com for a variety of ways to set your API key.'
              });
            case 8:
              url = this._url(baseConfig, config, operation);
              headers = this._headers(baseConfig, config);
              reqConfig = {
                headers: headers,
                maxContentLength: MAX_BODY_LENGTH,
                maxBodyLength: MAX_BODY_LENGTH
              };
              finalPayload = undefined;
              if (!(verb == 'POST' && config != null && config.file)) {
                _context7.next = 35;
                break;
              }
              contentType = undefined;
              if (typeof config.file != 'string') {
                contentType = 'binary/octet-stream';
              }

              // Important so proper boundary can be set;
              delete reqConfig.headers['Content-Type'];
              if (!isNode()) {
                _context7.next = 28;
                break;
              }
              _context7.next = 19;
              return import('form-data');
            case 19:
              FormDataNode = _context7.sent;
              formData = new FormDataNode["default"]();
              formData.append('file', Buffer.from(config.file), {
                filename: config == null ? void 0 : config.filename,
                contentType: contentType
              });
              pp = payload;
              for (_i2 = 0, _Object$keys = Object.keys(pp); _i2 < _Object$keys.length; _i2++) {
                _key2 = _Object$keys[_i2];
                value = pp[_key2];
                addMultiparts(formData, _key2, value);
              }
              finalPayload = formData;

              // This only needs to happen on Node.
              // And the .getHeaders method is unavilabile in the browser.
              // NOTE: This is untested in the unit tests; it will show up as a failure in the browser.
              // TODO: We need to start running tests inside a browser runtime too.
              reqConfig.headers = _extends({}, reqConfig.headers, formData.getHeaders());
              _context7.next = 33;
              break;
            case 28:
              _formData = new FormData();
              /*
               * The config.file as any cast below is because FormData does not support Buffer.
               * In general, file as a Buffer should only be done from within the NodeJS environment,
               * not from within the browser. In the browser, Blob should be used instead.
               *
               * TODO: Figure out if there's a way to strongly type (or at least runtime check) this
               * so that we get back intelligent errors that are environment-dependent.
               */
              _formData.append('file', config.file, config == null ? void 0 : config.filename);
              _pp = payload;
              for (_i3 = 0, _Object$keys2 = Object.keys(_pp); _i3 < _Object$keys2.length; _i3++) {
                _key3 = _Object$keys2[_i3];
                _value = _pp[_key3];
                addMultiparts(_formData, _key3, _value);
              }
              finalPayload = _formData;
            case 33:
              _context7.next = 36;
              break;
            case 35:
              if (typeof payload == 'object') {
                finalPayload = JSON.stringify(payload);
              } else {
                finalPayload = payload;
              }
            case 36:
              _context7.prev = 36;
              if (!(verb == 'POST')) {
                _context7.next = 43;
                break;
              }
              _context7.next = 40;
              return doFetch(url, {
                method: verb,
                body: finalPayload,
                headers: reqConfig.headers,
                responseType: config == null ? void 0 : config.responseType
              });
            case 40:
              resp = _context7.sent;
              _context7.next = 51;
              break;
            case 43:
              if (!(verb == 'GET')) {
                _context7.next = 50;
                break;
              }
              // TODO: Incorporate params into the query string
              if (payload) {
                url = url + '?' + new URLSearchParams(payload);
              }
              _context7.next = 47;
              return doFetch(url, {
                method: verb,
                headers: reqConfig.headers,
                responseType: config == null ? void 0 : config.responseType
              });
            case 47:
              resp = _context7.sent;
              _context7.next = 51;
              break;
            case 50:
              throw new SteamshipError({
                statusMessage: "Unsupported HTTP Verb: " + verb
              });
            case 51:
              _context7.next = 56;
              break;
            case 53:
              _context7.prev = 53;
              _context7.t1 = _context7["catch"](36);
              throw this._makeError({
                error: _context7.t1
              });
            case 56:
              return _context7.abrupt("return", this._makeResponse({
                response: resp,
                rawResponse: config == null ? void 0 : config.rawResponse,
                objectConstructor: config == null ? void 0 : config.expect,
                responsePath: config == null ? void 0 : config.responsePath
              }));
            case 57:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[36, 53]]);
      }));
      function call(_x14, _x15, _x16, _x17, _x18) {
        return _call.apply(this, arguments);
      }
      return call;
    }()
  }]);
  return ApiBase;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheGlvcyIsImdldExvZ2dlciIsImxvYWRDb25maWd1cmF0aW9uIiwiU3RlYW1zaGlwRXJyb3IiLCJUYXNrIiwiVGFza1N0YXRlIiwiaXNOb2RlIiwiZG9GZXRjaCIsInVybCIsIm9wdHMiLCJoZWFkZXJzIiwiZGF0YSIsImJvZHkiLCJtZXRob2QiLCJyZXNwb25zZVR5cGUiLCJsb2ciLCJNQVhfQk9EWV9MRU5HVEgiLCJfU1VCRE9NQUlOX1JFV1JJVElOR19FTkRQT0lOVFMiLCJfVVNFX1NVQkRPTUFJTl9SRVdSSVRJTkciLCJiYXNlIiwicyIsImluY2x1ZGVzIiwiYWRkTXVsdGlwYXJ0cyIsImZvcm1EYXRhIiwicGF0aCIsInZhbHVlIiwidHlwZSIsImFwcGVuZCIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJzdWJWYWx1ZSIsImluZGV4Iiwia2V5IiwiQXBpQmFzZSIsInBhcmFtcyIsImNvbmZpZyIsInRoZW4iLCJhcGlLZXkiLCJfc3dpdGNoQ29uZmlnV29ya3NwYWNlIiwid29ya3NwYWNlSGFuZGxlIiwid29ya3NwYWNlIiwiZmFpbElmV29ya3NwYWNlRXhpc3RzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbmZvIiwid29ya3NwYWNlSWQiLCJ1bmRlZmluZWQiLCJwIiwib2xkQ29uZmlnIiwiYWN0aXZlQ29uZmlnIiwicG9zdCIsImhhbmRsZSIsImZldGNoSWZFeGlzdHMiLCJyZXNwb25zZVBhdGgiLCJvdXRwdXQiLCJzdGF0dXNNZXNzYWdlIiwicmV0dXJuSWQiLCJpZCIsInJldHVybkhhbmRsZSIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInBvc3RDb25maWciLCJyZXQiLCJBdXRob3JpemF0aW9uIiwiaXNQYWNrYWdlQ2FsbCIsInBhY2thZ2VPd25lciIsInBhY2thZ2VJZCIsInBhY2thZ2VJbnN0YW5jZUlkIiwiYXNCYWNrZ3JvdW5kVGFzayIsImJhc2VDb25maWciLCJvcGVyYXRpb24iLCJhcGlCYXNlIiwic3RhdHVzQ29kZSIsInN0YXR1c1N1Z2dlc3Rpb24iLCJhcHBCYXNlIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsImpvaW4iLCJzbGljZSIsInBheWxvYWQiLCJvdmVycmlkZUNvbmZpZyIsImNhbGwiLCJyZXNwb25zZSIsInRhc2siLCJqIiwic3RhdHVzIiwicmF3UmVzcG9uc2UiLCJvYmplY3RDb25zdHJ1Y3RvciIsIl9tYWtlRXJyb3IiLCJlcnIiLCJqc29uIiwidGFza1BhcmFtcyIsInN0YXRlIiwiZmFpbGVkIiwic2V0RGF0YSIsInZlcmIiLCJfdXJsIiwiX2hlYWRlcnMiLCJyZXFDb25maWciLCJtYXhDb250ZW50TGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsImZpbmFsUGF5bG9hZCIsImZpbGUiLCJjb250ZW50VHlwZSIsIkZvcm1EYXRhTm9kZSIsIkJ1ZmZlciIsImZyb20iLCJmaWxlbmFtZSIsInBwIiwiT2JqZWN0Iiwia2V5cyIsImdldEhlYWRlcnMiLCJGb3JtRGF0YSIsInJlc3AiLCJVUkxTZWFyY2hQYXJhbXMiLCJfbWFrZVJlc3BvbnNlIiwiZXhwZWN0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9hcGlfYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MsIHsgQXhpb3NSZXNwb25zZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ3RzbG9nJztcblxuaW1wb3J0IGdldExvZ2dlciBmcm9tICcuL2xvZy5qcyc7XG5pbXBvcnQge1xuICBJQXBpQmFzZSxcbiAgSVRhc2ssXG4gIFBvc3RDb25maWcsXG4gIFN3aXRjaFdvcmtzcGFjZVBhcmFtcyxcbiAgVmVyYixcbn0gZnJvbSAnLi9zaGFyZWQvQmFzZUludGVyZmFjZXMuanMnO1xuaW1wb3J0IHtcbiAgQ29uZmlndXJhdGlvbixcbiAgTG9hZENvbmZpZ1BhcmFtcyxcbiAgbG9hZENvbmZpZ3VyYXRpb24sXG59IGZyb20gJy4vc2hhcmVkL0NvbmZpZ3VyYXRpb24uanMnO1xuaW1wb3J0IHsgU3RlYW1zaGlwRXJyb3IgfSBmcm9tICcuL3N0ZWFtc2hpcF9lcnJvci5qcyc7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi90YXNrLmpzJztcbmltcG9ydCB7IFRhc2tQYXJhbXMsIFRhc2tTdGF0ZSB9IGZyb20gJy4vdHlwZXMvYmFzZS5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuYXN5bmMgZnVuY3Rpb24gZG9GZXRjaCh1cmw6IGFueSwgb3B0czogYW55KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPiB7XG4gIHJldHVybiBheGlvcyh7XG4gICAgdXJsLFxuICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbiAgICBkYXRhOiBvcHRzLmJvZHksXG4gICAgbWV0aG9kOiBvcHRzLm1ldGhvZCxcbiAgICByZXNwb25zZVR5cGU6IG9wdHMucmVzcG9uc2VUeXBlLFxuICB9KTtcbn1cblxuLy8gYXN5bmMgZnVuY3Rpb24gZG9GZXRjaCh1cmw6IGFueSwgb3B0czogYW55KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPiB7XG4vLyAgIHJldHVybiBuZXcgUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4vLyAgICAgYXhpb3Moe1xuLy8gICAgICAgdXJsLFxuLy8gICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzLFxuLy8gICAgICAgZGF0YTogb3B0cy5ib2R5LFxuLy8gICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCxcbi8vICAgICB9KS50aGVuKHJlc29sdmUpXG4vLyAgICAgICAuY2F0Y2goXG4vLyAgICAgICAgIChlcnIpID0+IHtcbi8vICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuLy8gICAgICAgICAgIHJlamVjdChlcnIpO1xuLy8gICAgICAgICB9XG4vLyAgICAgICApXG4vLyAgIH0pXG4vLyB9XG5cbmNvbnN0IGxvZzogTG9nZ2VyID0gZ2V0TG9nZ2VyKCdTdGVhbXNoaXA6QXBpQmFzZScpO1xuXG5jb25zdCBNQVhfQk9EWV9MRU5HVEggPSAxMDAwMDAgKiAxMDAwO1xuXG5jb25zdCBfU1VCRE9NQUlOX1JFV1JJVElOR19FTkRQT0lOVFMgPSBbXG4gICcvL3N0ZWFtc2hpcC5ydW4nLFxuICAnLy9hcHBzLnN0YWdpbmcuc3RlYW1zaGlwLmNvbScsXG5dO1xuXG5jb25zdCBfVVNFX1NVQkRPTUFJTl9SRVdSSVRJTkcgPSAoYmFzZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGZvciAoY29uc3QgcyBvZiBfU1VCRE9NQUlOX1JFV1JJVElOR19FTkRQT0lOVFMpIHtcbiAgICBpZiAoYmFzZS5pbmNsdWRlcyhzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIFNob3VsZCBiZSBhIEZvcm1EYXRhIG9iamVjdCAqL1xuZnVuY3Rpb24gYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YTogYW55LCBwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgLyogRGVjb2RlIGFueSBvYmplY3QgaW50byBhIHNlcmllcyBvZiBIVFRQIE11bHRpLXBhcnQgc2VnbWVudHMgdGhhdCBWYXBvciB3aWxsIGNvbnN1bWUuXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL3ZhcG9yL211bHRpcGFydC1raXRcblxuICAgIFdoZW4gc2VuZGluZyBhIEpTT04gb2JqZWN0IGluIGEgTXVsdGlQYXJ0IHJlcXVlc3QsIFZhcG9yIHdpc2hlcyB0byBzZWUgbXVsdGkgcGFydCBzZWdtZW50cyBhcyBmb2xsb3dzOlxuICAgIHNpbmdsZV9rZXlcbiAgICBhcnJheV9rZXlbaWR4XVxuICAgIG9ial9rZXlbcHJvcF1cblxuICAgIFNvIGEgRmlsZSB3aXRoIGEgbGlzdCBvZiBvbmUgdGFnIHdpdGgga2luZD1Gb28gd291bGQgYmUgdHJhbnNtaXR0ZWQgYXMgc2V0dGluZyB0aGUgcGFydDpcbiAgICBbdGFnc11bMF1ba2luZF1cbiAgKi9cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgIGZvcm1EYXRhLmFwcGVuZChwYXRoLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKChzdWJWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGFkZE11bHRpcGFydHMoZm9ybURhdGEsIGAke3BhdGh9WyR7aW5kZXh9XWAsIHN1YlZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YSwgYCR7cGF0aH1bJHtrZXl9XWAsIHZhbHVlW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN3aXRjaENvbmZpZ1dvcmtzcGFjZVBhcmFtcyB7XG4gIHdvcmtzcGFjZUhhbmRsZT86IHN0cmluZztcbiAgZmFpbElmV29ya3NwYWNlRXhpc3RzPzogYm9vbGVhbjtcbiAgY29uZmlnOiBDb25maWd1cmF0aW9uO1xufVxuXG5leHBvcnQgY2xhc3MgQXBpQmFzZSBpbXBsZW1lbnRzIElBcGlCYXNlIHtcbiAgY29uZmlnOiBQcm9taXNlPENvbmZpZ3VyYXRpb24+IHwgQ29uZmlndXJhdGlvbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocGFyYW1zPzogTG9hZENvbmZpZ1BhcmFtcykge1xuICAgIHRoaXMuY29uZmlnID0gbG9hZENvbmZpZ3VyYXRpb24ocGFyYW1zKS50aGVuKChjb25maWcpID0+IHtcbiAgICAgIGlmIChjb25maWcuYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zd2l0Y2hDb25maWdXb3Jrc3BhY2Uoe1xuICAgICAgICAgIHdvcmtzcGFjZUhhbmRsZTogcGFyYW1zPy53b3Jrc3BhY2UsXG4gICAgICAgICAgZmFpbElmV29ya3NwYWNlRXhpc3RzOiBwYXJhbXM/LmZhaWxJZldvcmtzcGFjZUV4aXN0cyA9PT0gdHJ1ZSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHN3aXRjaFdvcmtzcGFjZShwYXJhbXM/OiBTd2l0Y2hXb3Jrc3BhY2VQYXJhbXMpIHtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLl9zd2l0Y2hDb25maWdXb3Jrc3BhY2Uoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgY29uZmlnOiBhd2FpdCB0aGlzLmNvbmZpZyxcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZyA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIGxvZy5pbmZvKFxuICAgICAgYFN3aXRjaGVkIHRvIHdvcmtzcGFjZSAke2NvbmZpZy53b3Jrc3BhY2VIYW5kbGV9LyR7Y29uZmlnLndvcmtzcGFjZUlkfWBcbiAgICApO1xuICB9XG5cbiAgLypcbiAgICBTd2l0Y2hlcyB0aGlzIGNsaWVudCB0byB0aGUgcmVxdWVzdGVkIHdvcmtzcGFjZSwgcG9zc2libHkgY3JlYXRpbmcgaXQuIElmIGFsbCBhcmd1bWVudHMgYXJlIE5vbmUsIHRoZSBjbGllbnRcbiAgICBhY3RpdmVseSBzd2l0Y2hlcyBpbnRvIHRoZSBkZWZhdWx0IHdvcmtzcGFjZS5cblxuICAgIC0gQVBJIGNhbGxzIGFyZSBwZXJmb3JtZWQgbWFudWFsbHkgdG8gbm90IHJlc3VsdCBpbiBjaXJjdWxhciBpbXBvcnRzLlxuICAgIC0gTm90ZSB0aGF0IHRoZSBkZWZhdWx0IHdvcmtzcGFjZSBpcyB0ZWNobmljYWxseSBub3QgbmVjZXNzYXJ5IGZvciBBUEkgdXNhZ2U7IGl0IHdpbGwgYmUgYXNzdW1lZCBieSB0aGUgRW5naW5lXG4gICAgICBpbiB0aGUgYWJzZW5zZSBvZiBhIFdvcmtzcGFjZSBJRCBvciBIYW5kbGUgYmVpbmcgbWFudWFsbHkgc3BlY2lmaWVkIGluIHJlcXVlc3QgaGVhZGVycy5cbiAgICovXG4gIGFzeW5jIF9zd2l0Y2hDb25maWdXb3Jrc3BhY2UoXG4gICAgcGFyYW1zOiBTd2l0Y2hDb25maWdXb3Jrc3BhY2VQYXJhbXNcbiAgKTogUHJvbWlzZTxDb25maWd1cmF0aW9uPiB7XG4gICAgbGV0IHdvcmtzcGFjZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHA6IFN3aXRjaFdvcmtzcGFjZVBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG5cbiAgICBpZiAoIXAud29ya3NwYWNlSGFuZGxlKSB7XG4gICAgICBwLndvcmtzcGFjZUhhbmRsZSA9ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBpZiAocC5mYWlsSWZXb3Jrc3BhY2VFeGlzdHMpIHtcbiAgICAgIGxvZy5pbmZvKGBDcmVhdGluZyB3b3Jrc3BhY2Ugd2l0aCBoYW5kbGU6ICR7cC53b3Jrc3BhY2VIYW5kbGV9LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbyhcbiAgICAgICAgYENyZWF0aW5nL0ZldGNoaW5nIHdvcmtzcGFjZSB3aXRoIGhhbmRsZTogJHtwLndvcmtzcGFjZUhhbmRsZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBaZXJvIG91dCB0aGUgd29ya3NwYWNlX2hhbmRsZSBvbiB0aGUgY29uZmlnIGJsb2NrIGluIGNhc2Ugd2UncmUgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gYGluaXRgIChvdGhlcndpc2Ugd2UnbGwgYXR0ZW1wdCB0byBjcmVhdGUgdGhlIHNhcGNlIElOIHRoYXQgbm9uZXhpc3RhbnQgd29ya3NwYWNlKVxuICAgIGNvbnN0IG9sZENvbmZpZyA9IHBhcmFtcy5jb25maWc7XG5cbiAgICBjb25zdCBhY3RpdmVDb25maWcgPSB7XG4gICAgICAuLi5vbGRDb25maWcsXG4gICAgICB3b3Jrc3BhY2VIYW5kbGU6IHVuZGVmaW5lZCxcbiAgICAgIHdvcmtzcGFjZUlkOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIHdvcmtzcGFjZSA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgICd3b3Jrc3BhY2UvY3JlYXRlJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlOiBwLndvcmtzcGFjZUhhbmRsZSxcbiAgICAgICAgZmV0Y2hJZkV4aXN0czogIShwLmZhaWxJZldvcmtzcGFjZUV4aXN0cyA9PT0gdHJ1ZSksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZXNwb25zZVBhdGg6ICd3b3Jrc3BhY2UnLFxuICAgICAgfSxcbiAgICAgIGFjdGl2ZUNvbmZpZ1xuICAgICk7XG5cbiAgICBpZiAoIXdvcmtzcGFjZSB8fCAhd29ya3NwYWNlLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgc3RhdHVzTWVzc2FnZTpcbiAgICAgICAgICAnV2FzIHVuYWJsZSB0byBzd2l0Y2ggdG8gbmV3IHdvcmtzcGFjZTogc2VydmVyIHJldHVybmVkIGVtcHR5IFdvcmtzcGFjZS4nLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuSWQ6IHN0cmluZyA9IHdvcmtzcGFjZS5vdXRwdXQuaWQ7XG4gICAgY29uc3QgcmV0dXJuSGFuZGxlOiBzdHJpbmcgPSB3b3Jrc3BhY2Uub3V0cHV0LmhhbmRsZTtcblxuICAgIGlmICghcmV0dXJuSGFuZGxlIHx8ICFyZXR1cm5JZCkge1xuICAgICAgbG9nLmVycm9yKHdvcmtzcGFjZSk7XG4gICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICBzdGF0dXNNZXNzYWdlOiBgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB3b3Jrc3BhY2VcbiAgICAgICAgKX0gVW5hYmxlIHRvIHN3aXRjaCB0byB3b3Jrc3BhY2UgJHtcbiAgICAgICAgICBwLndvcmtzcGFjZUhhbmRsZVxuICAgICAgICB9IHdpdGggZmFpbElmV29ya3NwYWNlRXhpc3RzICR7XG4gICAgICAgICAgcC5mYWlsSWZXb3Jrc3BhY2VFeGlzdHNcbiAgICAgICAgfTogc2VydmVyIHJldHVybmVkIGVtcHR5IElEIGFuZCBIYW5kbGUuYCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHNldCB0aGUgbmV3IHdvcmtzcGFjZVxuICAgIHJldHVybiB7XG4gICAgICAuLi5vbGRDb25maWcsXG4gICAgICB3b3Jrc3BhY2VIYW5kbGU6IHJldHVybkhhbmRsZSxcbiAgICAgIHdvcmtzcGFjZUlkOiByZXR1cm5JZCxcbiAgICB9O1xuICB9XG5cbiAgX2hlYWRlcnM8VD4oXG4gICAgY29uZmlnOiBDb25maWd1cmF0aW9uLFxuICAgIHBvc3RDb25maWc/OiBQb3N0Q29uZmlnPFQ+XG4gICk6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9IHtcbiAgICBjb25zdCByZXQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcuYXBpS2V5fWAsXG4gICAgfTtcblxuICAgIGlmIChwb3N0Q29uZmlnPy53b3Jrc3BhY2VJZCkge1xuICAgICAgcmV0WydYLVdvcmtzcGFjZS1JZCddID0gcG9zdENvbmZpZz8ud29ya3NwYWNlSWQ7XG4gICAgfSBlbHNlIGlmIChjb25maWcud29ya3NwYWNlSWQpIHtcbiAgICAgIHJldFsnWC1Xb3Jrc3BhY2UtSWQnXSA9IGNvbmZpZy53b3Jrc3BhY2VJZDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy53b3Jrc3BhY2VIYW5kbGUpIHtcbiAgICAgIHJldFsnWC1Xb3Jrc3BhY2UtSGFuZGxlJ10gPSBjb25maWcud29ya3NwYWNlSGFuZGxlO1xuICAgIH1cblxuICAgIGlmIChwb3N0Q29uZmlnPy5pc1BhY2thZ2VDYWxsID09PSB0cnVlKSB7XG4gICAgICBpZiAocG9zdENvbmZpZz8ucGFja2FnZU93bmVyKSB7XG4gICAgICAgIHJldFsnWC1QYWNrYWdlLU93bmVyLUhhbmRsZSddID0gcG9zdENvbmZpZy5wYWNrYWdlT3duZXI7XG4gICAgICB9XG4gICAgICBpZiAocG9zdENvbmZpZz8ucGFja2FnZUlkKSB7XG4gICAgICAgIHJldFsnWC1QYWNrYWdlLUlkJ10gPSBwb3N0Q29uZmlnLnBhY2thZ2VJZDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0Q29uZmlnPy5wYWNrYWdlSW5zdGFuY2VJZCkge1xuICAgICAgICByZXRbJ1gtUGFja2FnZS1JbnN0YW5jZS1JZCddID0gcG9zdENvbmZpZy5wYWNrYWdlSW5zdGFuY2VJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zdENvbmZpZz8uYXNCYWNrZ3JvdW5kVGFzayA9PT0gdHJ1ZSkge1xuICAgICAgLy8gV2lsbCByZXN1bHQgaW4gdGhlIGVuZ2luZSBwZXJzaXN0aW5nIHRoZSBpbmJvdW5kIEhUVFAgcmVxdWVzdCBhcyBhIFRhc2sgZm9yIGRlZmVycmVkXG4gICAgICAvLyBleGVjdXRpb24uIFRoZSBjbGllbnQgd2lsbCByZWNlaXZlIHRhc2sgaW5mb3JtYXRpb24gYmFjayBpbnN0ZWFkIG9mIHRoZSBzeW5jaHJvbm91cyBBUEkgcmVzcG9uc2UuXG4gICAgICAvLyBUaGF0IHRhc2sgY2FuIGJlIHBvbGxlZCBmb3IgZXZlbnR1YWwgY29tcGxldGlvbi5cbiAgICAgIHJldFsnWC1UYXNrLUJhY2tncm91bmQnXSA9ICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIF91cmw8VD4oXG4gICAgYmFzZUNvbmZpZzogQ29uZmlndXJhdGlvbixcbiAgICBwb3N0Q29uZmlnPzogUG9zdENvbmZpZzxUPixcbiAgICBvcGVyYXRpb24/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgYmFzZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gJyc7XG5cbiAgICBpZiAoIShwb3N0Q29uZmlnPy5pc1BhY2thZ2VDYWxsID09PSB0cnVlKSkge1xuICAgICAgLy8gSXQncyBhbiBBUEkgY2FsbFxuICAgICAgYmFzZSA9IHBvc3RDb25maWc/LmFwaUJhc2UgfHwgYmFzZUNvbmZpZy5hcGlCYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJdCdzIGEgcGFja2FnZSBjYWxsXG4gICAgICBpZiAoIXBvc3RDb25maWc/LnBhY2thZ2VPd25lcikge1xuICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgIHN0YXR1c0NvZGU6ICdVc2VyTWlzc2luZycsXG4gICAgICAgICAgc3RhdHVzTWVzc2FnZTpcbiAgICAgICAgICAgIFwiQ2FuIG5vdCBpbnZva2UgYW4gcGFja2FnZSBlbmRwb2ludCB3aXRob3V0IHRoZSBwYWNrYWdlIG93bmVyJ3MgdXNlciBoYW5kbGUuXCIsXG4gICAgICAgICAgc3RhdHVzU3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICdQcm92aWRlIHRoZSBwYWNrYWdlT3duZXIgb3B0aW9uLCBvciBpbml0aWFsaXplIHlvdXIgcGFja2FnZSB3aXRoIGEgbG9va3VwLicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBiYXNlID0gcG9zdENvbmZpZz8uYXBwQmFzZSB8fCBiYXNlQ29uZmlnLmFwcEJhc2U7XG5cbiAgICAgIGlmICghYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgIHN0YXR1c0NvZGU6ICdFbmRwb2ludE1pc3NpbmcnLFxuICAgICAgICAgIHN0YXR1c01lc3NhZ2U6XG4gICAgICAgICAgICAnQ2FuIG5vdCBpbnZva2UgYW4gcGFja2FnZSBlbmRwb2ludCB3aXRob3V0IHRoZSBBcHAgQmFzZSB2YXJpYWJsZSBzZXQuJyxcbiAgICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOlxuICAgICAgICAgICAgJ1RoaXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgaGF2ZSBhIGdvb2QgZGVmYXVsdCBzZXR0aW5nLiBSZWFjaCBvdXQgdG8gb3VyIFN0ZWFtc2hpcCBzdXBwb3J0LicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX1VTRV9TVUJET01BSU5fUkVXUklUSU5HKGJhc2UpKSB7XG4gICAgICAgIC8vIFJld3JpdGUgdGhlIGJhc2UgdG8gYmUgaHR0cHM6Ly91c2VyLmJhc2VcbiAgICAgICAgY29uc3QgcGFydHMgPSBiYXNlLnNwbGl0KCcvLycpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBTdGVhbXNoaXBFcnJvcih7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiAnRW5kcG9pbnRJbnZhbGlkJyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6XG4gICAgICAgICAgICAgICdZb3UgcGFja2FnZSBiYXNlIGRpZCBub3QgYXBwZWFyIHRvIGJlZ2luIHdpdGggYSB2YWxpZCBIVFRQIG9yIEhUVFBTIHByb3RvY29sLicsXG4gICAgICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOlxuICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB5b3UndmUgcHJvdmlkZWQgYW4gYXBwIGJhc2Ugc3VjaCBhcyBodHRwczovL3N0ZWFtc2hpcC5ydW4sIHdpdGggdGhlIHByb3RvY29sLlwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBwcmUtcGVuZCB0aGUgYXBwLWJhc2UgdG8gdGhlIGZpcnN0IHBhcnQhXG4gICAgICAgIHBhcnRzWzFdID0gYCR7cG9zdENvbmZpZz8ucGFja2FnZU93bmVyfS4ke3BhcnRzWzFdfWA7XG4gICAgICAgIGJhc2UgPSBwYXJ0cy5qb2luKCcvLycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEd1YXJkIGFnYWluc3QgYSBkb3VibGUgLy8gYWZ0ZXIgdGhlIGRvbWFpblxuXG4gICAgaWYgKGJhc2UgJiYgYmFzZVtiYXNlLmxlbmd0aCAtIDFdID09ICcvJykge1xuICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UoMCwgYmFzZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKG9wZXJhdGlvbiAmJiBvcGVyYXRpb25bMF0gPT0gJy8nKSB7XG4gICAgICBvcGVyYXRpb24gPSBvcGVyYXRpb24uc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtiYXNlfS8ke29wZXJhdGlvbn1gO1xuICB9XG5cbiAgYXN5bmMgcG9zdDxUPihcbiAgICBvcGVyYXRpb246IHN0cmluZyxcbiAgICBwYXlsb2FkOiB1bmtub3duLFxuICAgIGNvbmZpZz86IFBvc3RDb25maWc8VD4sXG4gICAgb3ZlcnJpZGVDb25maWc/OiBDb25maWd1cmF0aW9uXG4gICk6IFByb21pc2U8QXhpb3NSZXNwb25zZSB8IElUYXNrPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbCgnUE9TVCcsIG9wZXJhdGlvbiwgcGF5bG9hZCwgY29uZmlnLCBvdmVycmlkZUNvbmZpZyk7XG4gIH1cblxuICBhc3luYyBnZXQ8VD4oXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gICAgcGF5bG9hZDogdW5rbm93bixcbiAgICBjb25maWc/OiBQb3N0Q29uZmlnPFQ+XG4gICk6IFByb21pc2U8QXhpb3NSZXNwb25zZSB8IElUYXNrPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbCgnR0VUJywgb3BlcmF0aW9uLCBwYXlsb2FkLCBjb25maWcpO1xuICB9XG5cbiAgYXN5bmMgX21ha2VFcnJvcjxUPih7XG4gICAgZXJyb3IsXG4gICAgcmVzcG9uc2UsXG4gICAgdGFzayxcbiAgfToge1xuICAgIGVycm9yPzogRXJyb3I7XG4gICAgcmVzcG9uc2U/OiBBeGlvc1Jlc3BvbnNlO1xuICAgIHRhc2s/OiBJVGFzazxUPjtcbiAgfSk6IFByb21pc2U8RXJyb3I+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqID0gYXdhaXQgcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgaWYgKGouc3RhdHVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBqLnN0YXR1cy5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogai5zdGF0dXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIHN0YXR1c1N1Z2dlc3Rpb246IGouc3RhdHVzLnN0YXR1c1N1Z2dlc3Rpb24sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlOiAnQmFkIHJlc3BvbnNlIGZyb20gc2VydmVyJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0ZWFtc2hpcEVycm9yKHsgc3RhdHVzTWVzc2FnZTogJ0JhZCByZXNwb25zZSBmcm9tIHNlcnZlcicgfSk7XG4gICAgfSBlbHNlIGlmICh0YXNrKSB7XG4gICAgICByZXR1cm4gbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogdGFzay5zdGF0dXNNZXNzYWdlLFxuICAgICAgICBzdGF0dXNDb2RlOiB0YXNrLnN0YXR1c0NvZGUsXG4gICAgICAgIHN0YXR1c1N1Z2dlc3Rpb246IHRhc2suc3RhdHVzU3VnZ2VzdGlvbixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0ZWFtc2hpcEVycm9yKHsgc3RhdHVzTWVzc2FnZTogJ0JhZCByZXNwb25zZScgfSk7XG4gIH1cblxuICBhc3luYyBfbWFrZVJlc3BvbnNlPFQ+KHtcbiAgICByZXNwb25zZSxcbiAgICByYXdSZXNwb25zZSxcbiAgICBvYmplY3RDb25zdHJ1Y3RvcixcbiAgICByZXNwb25zZVBhdGgsXG4gIH06IHtcbiAgICByZXNwb25zZTogQXhpb3NSZXNwb25zZTtcbiAgICByYXdSZXNwb25zZT86IGJvb2xlYW47XG4gICAgcmVzcG9uc2VQYXRoPzogc3RyaW5nO1xuICAgIG9iamVjdENvbnN0cnVjdG9yPzogKGNsaWVudDogYW55LCBkYXRhOiBhbnkpID0+IFQ7XG4gIH0pOiBQcm9taXNlPFRhc2s8VD4gfCBBeGlvc1Jlc3BvbnNlPiB7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHsgc3RhdHVzTWVzc2FnZTogJ05vIHJlc3BvbnNlLicgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPSAyMDApIHtcbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IHRoaXMuX21ha2VFcnJvcih7IHJlc3BvbnNlIH0pO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlmIChyYXdSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGxldCBqc29uOiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSByZXNwb25zZS5kYXRhOyAvLyBBeGlvc1xuICAgICAgLy8ganNvbiA9IEpTT04ucGFyc2UoKHJlc3BvbnNlIGFzIGFueSkuYm9keSk7IC8vIEdvdFxuICAgICAgLy8ganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsgLy8gZm9yIHRoZSBmZXRjaCBzdHlsZSAvLyBGZXRjaFxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGF3YWl0IHRoaXMuX21ha2VFcnJvcih7IGVycm9yIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YganNvbiA9PSAndW5kZWZpbmVkJyB8fCBqc29uID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdFbXB0eSByZXNwb25zZS4nIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRhc2tQYXJhbXM6IFRhc2tQYXJhbXM8VD4gPSBqc29uPy5zdGF0dXMgYXMgVGFza1BhcmFtczxUPjtcbiAgICBsZXQgdGFzazogVGFzazxUPjtcblxuICAgIGlmICh0eXBlb2YgdGFza1BhcmFtcz8uc3RhdGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRhc2sgPSBuZXcgVGFzayh0aGlzLCB7XG4gICAgICAgIC4uLnRhc2tQYXJhbXMsXG4gICAgICAgIHJlc3BvbnNlUGF0aDogcmVzcG9uc2VQYXRoLFxuICAgICAgICByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UsXG4gICAgICAgIG9iamVjdENvbnN0cnVjdG9yOiBvYmplY3RDb25zdHJ1Y3RvcixcbiAgICAgIH0pO1xuICAgICAgaWYgKHRhc2s/LnN0YXRlID09IFRhc2tTdGF0ZS5mYWlsZWQpIHtcbiAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fbWFrZUVycm9yKHsgdGFzayB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFzayA9IG5ldyBUYXNrKHRoaXMsIHtcbiAgICAgICAgcmVzcG9uc2VQYXRoOiByZXNwb25zZVBhdGgsXG4gICAgICAgIHJhd1Jlc3BvbnNlOiByYXdSZXNwb25zZSxcbiAgICAgICAgb2JqZWN0Q29uc3RydWN0b3I6IG9iamVjdENvbnN0cnVjdG9yLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGFzay5zZXREYXRhKGpzb24/LmRhdGEpO1xuICAgIHJldHVybiB0YXNrO1xuICB9XG5cbiAgYXN5bmMgY2FsbDxUPihcbiAgICB2ZXJiOiBWZXJiLFxuICAgIG9wZXJhdGlvbjogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHVua25vd24sXG4gICAgY29uZmlnPzogUG9zdENvbmZpZzxUPixcbiAgICBvdmVycmlkZUNvbmZpZz86IENvbmZpZ3VyYXRpb25cbiAgKTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlIHwgVGFzazxUPj4ge1xuICAgIC8vIFRoaXMgb3ZlcnJpZGVDb25maWcgdmFyIGlzIG5lY2Vzc2FyeSBmb3IgdGhlIHN3aXRjaCBjb25maWcgb3BlcmF0aW9uIGF0IGluaXRcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gb3ZlcnJpZGVDb25maWcgfHwgKGF3YWl0IHRoaXMuY29uZmlnKTtcbiAgICBpZiAoIWJhc2VDb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICBzdGF0dXNDb2RlOiAnQXV0aGVudGljYXRpb24nLFxuICAgICAgICBzdGF0dXNNZXNzYWdlOiAnQVBJIEtleSBub3QgZm91bmQuJyxcbiAgICAgICAgc3RhdHVzU3VnZ2VzdGlvbjpcbiAgICAgICAgICAnUGxlYXNlIHNlZSBkb2NzLnN0ZWFtc2hpcC5jb20gZm9yIGEgdmFyaWV0eSBvZiB3YXlzIHRvIHNldCB5b3VyIEFQSSBrZXkuJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCB1cmwgPSB0aGlzLl91cmwoYmFzZUNvbmZpZywgY29uZmlnLCBvcGVyYXRpb24pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLl9oZWFkZXJzKGJhc2VDb25maWcsIGNvbmZpZyk7XG5cbiAgICBjb25zdCByZXFDb25maWcgPSB7XG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgbWF4Q29udGVudExlbmd0aDogTUFYX0JPRFlfTEVOR1RILFxuICAgICAgbWF4Qm9keUxlbmd0aDogTUFYX0JPRFlfTEVOR1RILFxuICAgIH07XG5cbiAgICBsZXQgZmluYWxQYXlsb2FkOiB1bmRlZmluZWQgfCB1bmtub3duIHwgeyBba2V5OiBzdHJpbmddOiB1bmRlZmluZWQgfSA9XG4gICAgICB1bmRlZmluZWQ7XG4gICAgaWYgKHZlcmIgPT0gJ1BPU1QnICYmIGNvbmZpZz8uZmlsZSkge1xuICAgICAgbGV0IGNvbnRlbnRUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZmlsZSAhPSAnc3RyaW5nJykge1xuICAgICAgICBjb250ZW50VHlwZSA9ICdiaW5hcnkvb2N0ZXQtc3RyZWFtJztcbiAgICAgIH1cblxuICAgICAgLy8gSW1wb3J0YW50IHNvIHByb3BlciBib3VuZGFyeSBjYW4gYmUgc2V0O1xuICAgICAgZGVsZXRlIHJlcUNvbmZpZy5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcblxuICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnN0IEZvcm1EYXRhTm9kZSA9IGF3YWl0IGltcG9ydCgnZm9ybS1kYXRhJyk7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhTm9kZS5kZWZhdWx0KCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIEJ1ZmZlci5mcm9tKGNvbmZpZy5maWxlIGFzIGFueSksIHtcbiAgICAgICAgICBmaWxlbmFtZTogY29uZmlnPy5maWxlbmFtZSxcbiAgICAgICAgICBjb250ZW50VHlwZTogY29udGVudFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcCA9IHBheWxvYWQgYXMgeyBba2V5OiBzdHJpbmddOiB1bmRlZmluZWQgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHApKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcFtrZXldO1xuICAgICAgICAgIGFkZE11bHRpcGFydHMoZm9ybURhdGEsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsUGF5bG9hZCA9IGZvcm1EYXRhO1xuXG4gICAgICAgIC8vIFRoaXMgb25seSBuZWVkcyB0byBoYXBwZW4gb24gTm9kZS5cbiAgICAgICAgLy8gQW5kIHRoZSAuZ2V0SGVhZGVycyBtZXRob2QgaXMgdW5hdmlsYWJpbGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgdW50ZXN0ZWQgaW4gdGhlIHVuaXQgdGVzdHM7IGl0IHdpbGwgc2hvdyB1cCBhcyBhIGZhaWx1cmUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gc3RhcnQgcnVubmluZyB0ZXN0cyBpbnNpZGUgYSBicm93c2VyIHJ1bnRpbWUgdG9vLlxuICAgICAgICByZXFDb25maWcuaGVhZGVycyA9IHsgLi4ucmVxQ29uZmlnLmhlYWRlcnMsIC4uLmZvcm1EYXRhLmdldEhlYWRlcnMoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGNvbmZpZy5maWxlIGFzIGFueSBjYXN0IGJlbG93IGlzIGJlY2F1c2UgRm9ybURhdGEgZG9lcyBub3Qgc3VwcG9ydCBCdWZmZXIuXG4gICAgICAgICAqIEluIGdlbmVyYWwsIGZpbGUgYXMgYSBCdWZmZXIgc2hvdWxkIG9ubHkgYmUgZG9uZSBmcm9tIHdpdGhpbiB0aGUgTm9kZUpTIGVudmlyb25tZW50LFxuICAgICAgICAgKiBub3QgZnJvbSB3aXRoaW4gdGhlIGJyb3dzZXIuIEluIHRoZSBicm93c2VyLCBCbG9iIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IEZpZ3VyZSBvdXQgaWYgdGhlcmUncyBhIHdheSB0byBzdHJvbmdseSB0eXBlIChvciBhdCBsZWFzdCBydW50aW1lIGNoZWNrKSB0aGlzXG4gICAgICAgICAqIHNvIHRoYXQgd2UgZ2V0IGJhY2sgaW50ZWxsaWdlbnQgZXJyb3JzIHRoYXQgYXJlIGVudmlyb25tZW50LWRlcGVuZGVudC5cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGNvbmZpZy5maWxlIGFzIGFueSwgY29uZmlnPy5maWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IHBwID0gcGF5bG9hZCBhcyB7IFtrZXk6IHN0cmluZ106IHVuZGVmaW5lZCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcCkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBwW2tleV07XG4gICAgICAgICAgYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxQYXlsb2FkID0gZm9ybURhdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGF5bG9hZCA9PSAnb2JqZWN0Jykge1xuICAgICAgZmluYWxQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmFsUGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgfVxuXG4gICAgbGV0IHJlc3A6IEF4aW9zUmVzcG9uc2U7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHZlcmIgPT0gJ1BPU1QnKSB7XG4gICAgICAgIHJlc3AgPSBhd2FpdCBkb0ZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogdmVyYixcbiAgICAgICAgICBib2R5OiBmaW5hbFBheWxvYWQgYXMgYW55LFxuICAgICAgICAgIGhlYWRlcnM6IHJlcUNvbmZpZy5oZWFkZXJzLFxuICAgICAgICAgIHJlc3BvbnNlVHlwZTogY29uZmlnPy5yZXNwb25zZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNwID0gYXdhaXQgYXhpb3MucG9zdCh1cmwsIGZpbmFsUGF5bG9hZCwgcmVxQ29uZmlnKTtcbiAgICAgIH0gZWxzZSBpZiAodmVyYiA9PSAnR0VUJykge1xuICAgICAgICAvLyBUT0RPOiBJbmNvcnBvcmF0ZSBwYXJhbXMgaW50byB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgdXJsID0gdXJsICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXlsb2FkIGFzIGFueSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcCA9IGF3YWl0IGRvRmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiB2ZXJiLFxuICAgICAgICAgIGhlYWRlcnM6IHJlcUNvbmZpZy5oZWFkZXJzLFxuICAgICAgICAgIHJlc3BvbnNlVHlwZTogY29uZmlnPy5yZXNwb25zZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNwID0gYXdhaXQgYXhpb3MuZ2V0KHVybCwgeyAuLi5yZXFDb25maWcsIHBhcmFtczogZmluYWxQYXlsb2FkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBgVW5zdXBwb3J0ZWQgSFRUUCBWZXJiOiAke3ZlcmJ9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgdGhpcy5fbWFrZUVycm9yKHsgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21ha2VSZXNwb25zZSh7XG4gICAgICByZXNwb25zZTogcmVzcCxcbiAgICAgIHJhd1Jlc3BvbnNlOiBjb25maWc/LnJhd1Jlc3BvbnNlLFxuICAgICAgb2JqZWN0Q29uc3RydWN0b3I6IGNvbmZpZz8uZXhwZWN0LFxuICAgICAgcmVzcG9uc2VQYXRoOiBjb25maWc/LnJlc3BvbnNlUGF0aCxcbiAgICB9KTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiK0NBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQSxPQUFPQSxLQUFLLE1BQXlCLE9BQU87QUFHNUMsT0FBT0MsU0FBUyxNQUFNLFVBQVU7QUFRaEMsU0FHRUMsaUJBQWlCLFFBQ1osMkJBQTJCO0FBQ2xDLFNBQVNDLGNBQWMsUUFBUSxzQkFBc0I7QUFDckQsU0FBU0MsSUFBSSxRQUFRLFdBQVc7QUFDaEMsU0FBcUJDLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkQsU0FBU0MsTUFBTSxRQUFRLFlBQVk7QUFBQyxTQUVyQkMsT0FBTztFQUFBO0FBQUEsRUFVdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtFQUFBLHNFQXpCQSxrQkFBdUJDLEdBQVEsRUFBRUMsSUFBUztJQUFBO01BQUE7UUFBQTtVQUFBLGtDQUNqQ1QsS0FBSyxDQUFDO1lBQ1hRLEdBQUcsRUFBSEEsR0FBRztZQUNIRSxPQUFPLEVBQUVELElBQUksQ0FBQ0MsT0FBTztZQUNyQkMsSUFBSSxFQUFFRixJ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